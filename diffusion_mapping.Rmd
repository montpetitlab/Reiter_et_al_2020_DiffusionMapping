---
title: "Diffusion mapping reveals vineyard-site specific fermentation trajectories"
always_allow_html: yes
author: 
- Taylor Reiter
- Rachel Montpetit
- ...
- C. Titus Brown--(do you want to be on the paper?)
- Ron Runnebaum
- Ben Montpetit
date: "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: ../2020-pn-tmp/bibliography.bib
graphics: yes
figsintext: yes
geometry: "left=1in,right=1in,top=1in,bottom=1in"
header-includes:
- \usepackage{verbatim}
- \newcommand{\comm}[1]{}
- \usepackage{float} \floatplacement{figure}{H}
- \newcommand{\beginsupplement}{\setcounter{table}{0}  \renewcommand{\thetable}{S\arabic{table}}
  \setcounter{figure}{0} \renewcommand{\thefigure}{S\arabic{figure}}}
- \usepackage[font={small,it}, labelfont={bf}]{caption}
- \usepackage{setspace}\doublespacing
keep_tex: yes
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: false
---
  
```{r setup, include=FALSE, eval = T}
knitr::opts_chunk$set(echo = F, eval = T, message = F, warning = F, cache = T, 
                      include = T, fig.keep = 'high', fig.path = "Rmd_fig_out/",
                      dpi=400, fig.width = 6.5)
```

```{r libs, eval = T}
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)
library(readr)
library(purrr)
library(stringr)
library(ggplot2)
library(ggthemes)
library(ggpubr)
library(ggrepel)
library(ggplotify)
library(ggcorrplot)
library(limma)
library(edgeR)
library(clusterProfiler)
library(org.Sc.sgd.db)
library(kableExtra)
library(gridExtra)
library(UpSetR)
library(cowplot)
library(knitr)
library(RColorBrewer)
set.seed(1)
```

```{r diffusion_mapping_functions}
## as implemented here: https://doi.org/10.6084/m9.figshare.12864011.v4
## standardize columns func
norm.mat <- function(mat){
  ms <- apply(mat, 2, function(col) (col - mean(col)) / sd(col))
  ms
}

## compute euclid dist and standrdize to similarities
get_euc <- function(mat, n.threads = 1, alt = 'euclidean'){
  if(n.threads > 1){
    eu <- parDist(mat, method = alt, threads = n.threads) %>% as.matrix()
    ieu <- 1 / eu
    diag(ieu) <- 0
  }
  
  if(n.threads == 1){
    eu <- dist(mat, method = alt) %>% as.matrix()
    ieu <- 1 / eu
    diag(ieu) <- 0
  }

  ieu
}

## function to threshold the normalized distance mat
threshold <- function(mat, top_k = 10){
  thr <- mat
  tnr <- nrow(thr)
  ## set similarities outside of the top k to 0
  for(i in 1:tnr){
    ## rank entries in each row in reverse order (so largest value == rank 1), 
    ## and set entries that are outside of 1:k to 0
    thr[i, !rank(-thr[i, ], ties.method = 'random') %in% 1:top_k] <- 0
  }
  
  for(i in 1:tnr){
    for(j in 1:tnr){
      if(thr[i, j] == 0 & thr[j, i] != 0){
        thr[i, j] <- thr[j, i]
      }
    }
  }
  thr
}

## function to calculate norm laplacian
get_laplac <- function(mat){
  L <- -mat
  S <- rowSums(mat)
  nL <- L / S
  diag(nL) <- 1
  nL
}
```

```{r processing_functions}
orf_to_common <- function(keys){
  common <- AnnotationDbi::select(org.Sc.sgd.db,
                                  keys = keys,
                                  columns=c("COMMON"),
                                  keytype="ORF")
  return(common)
}

lm_eqn <- function(df, y, x){
    formula = as.formula(sprintf('%s ~ %s', y, x))
    m <- lm(formula, data=df);
    # formating the values into a summary string to print out
    # ~ give some space, but equal size and comma need to be quoted
    eq <- substitute(italic(target) == a + b %.% italic(input)*","~~italic(r)^2~"="~r2*","~~p~"="~italic(pvalue), 
         list(target = y,
              input = x,
              a = format(as.vector(coef(m)[1]), digits = 2), 
              b = format(as.vector(coef(m)[2]), digits = 2), 
             r2 = format(summary(m)$r.squared, digits = 3),
             # getting the pvalue is painful
             pvalue = format(summary(m)$coefficients[2,'Pr(>|t|)'], digits=1)
            )
          )
    as.character(as.expression(eq));                 
}

dc_contrast <- function(dc_fit, coeff, adj.p.filt = 0.01, filter_logFC = T){
  # Test diffusion component coefficient
  dc_con <- contrasts.fit(dc_fit, coefficients = coeff)   
  dc_b <- eBayes(dc_con)
  dc_top <- topTable(dc_b, sort.by = "logFC", number = Inf)
  dc_top <- dc_top[dc_top$adj.P.Val < adj.p.filt, ]
  
  # Translate ORF to Common
  dc_top$ORF <- rownames(dc_top)
  commons <- orf_to_common(dc_top$ORF)
  # subset to first occurrence of ORF
  commons <- commons[match(unique(commons$ORF), commons$ORF), ]
  commons <- commons[ , -2]
  commons$COMMON <- ifelse(is.na(commons$COMMON), commons$ORF, commons$COMMON)
  commons <- unique(commons[ , ])
  dc_top <- left_join(dc_top, commons, by = c("ORF"))
  # normalize logfc based on min and max of DC
  normalizer <- max(dc_fit$design[ , coeff]) - min(dc_fit$design[ , coeff])
  dc_top <- dc_top %>%
    mutate(logFC_adj = logFC*normalizer)
  if(filter_logFC == F) {
    return(dc_top)
  } else {
    # Join Common to diffex results
    dc_top <- dc_top %>%
      filter(abs(logFC_adj) > 2)
    return(dc_top)
  }
}

dc_viz <- function(dc_con){
  # separate to induced and repressed
  up <- dc_con[dc_con$logFC > 0, ]
  down <- dc_con[dc_con$logFC < 0, ] 
  
  # KEGG enrichment
  ekegg_up <- enrichKEGG(up$ORF, "sce", pAdjustMethod = "bonferroni") 
  plt_rows <- ekegg_up@result %>%
    filter(p.adjust < .05) %>%
    nrow()
  plt1 <- dotplot(ekegg_up, showCategory = plt_rows, font.size = 5) + theme_minimal(base_size = 5)
  
  ekegg_down <- enrichKEGG(down$ORF, "sce", pAdjustMethod = "bonferroni")
  plt_rows <- ekegg_down@result %>%
    filter(p.adjust < .05) %>%
    nrow()
  plt2 <- dotplot(ekegg_down, showCategory = plt_rows, font.size = 5) + theme_minimal(base_size = 5)
  
  # GO enrichment
  ego_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                     ont = "ALL", pAdjustMethod = "bonferroni")
  plt_rows <- ego_up@result %>%
    filter(p.adjust < .05) %>%
    nrow()
  plt3 <- dotplot(ego_up, showCategory = plt_rows, font.size = 5) + theme_minimal(base_size = 5)
  
  ego_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                       ont = "ALL", pAdjustMethod = "bonferroni")
  plt_rows <- ego_down@result %>%
    filter(p.adjust < .05) %>%
    nrow()
  plt4 <- dotplot(ego_down, showCategory = plt_rows, font.size = 5) + theme_minimal(base_size = 5)
  
  # combine plots
  ggarrange(plt1, plt2, plt3, plt4, ncol = 2, nrow = 2, common.legend = T, 
            legend = "bottom", labels = c("A", "B", "C", "D"),
            heights = c(1, 2))
}

# this plot only makes sense when there are > ~10 genes per component that are
# differentially expressed
dc_top_enrich_plot <- function(dc, dc_num, dc_con, color_by = c("brix", "ava", "hr"), show_genes = F){
  # dc <- dc19
  # dc_num <- "DC3"
  # dc_con <- dc3_19
  # separate to induced and repressed -- note that filtering for 
  # log2fc is done in dc_contrast() when normalize_logFC = T. 
  # default is a normalizes logFC > abs(2) 
  # therefore, up down separates the positive and negative logFC values
  
  up <- dc_con[dc_con$logFC > 0, ]
  down <- dc_con[dc_con$logFC < 0, ] 
               
  # KEGG enrichment
  if(nrow(up) != 0){
    ekegg_up <- enrichKEGG(up$ORF, "sce", pAdjustMethod = "bonferroni") 
    ekegg_up_top <- ekegg_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "KEGG") 
  } else {
    ekegg_up_top <- data.frame("Description" = character(),
                               "geneID" = character(),
                               "enrichment" = character())
  }
  
  if(nrow(down) != 0){
    if(!identical(down$ORF, down$COMMON)) { # Filter out datasets where everything is unknown
      ekegg_down <- enrichKEGG(down$ORF, "sce", pAdjustMethod = "bonferroni")
      ekegg_down_top <- ekegg_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "KEGG")
    } else {
      ekegg_down_top <- data.frame("Description" = character(),
                                   "geneID" = character(),
                                   "enrichment" = character())
    }
  } else {
    ekegg_down_top <- data.frame("Description" = character(),
                                 "geneID" = character(),
                                 "enrichment" = character())
  }
  
  # GO enrichment
  if(nrow(up) != 0){
    ego_bp_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "BP", pAdjustMethod = "bonferroni")
    ego_bp_up_top <- ego_bp_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO BP")
    
    ego_mf_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "MF", pAdjustMethod = "bonferroni")
    ego_mf_up_top <- ego_mf_up@result%>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO MF")
    
    ego_cc_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "CC", pAdjustMethod = "bonferroni")
    ego_cc_up_top <- ego_cc_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO CC")
  } else {
    ego_cc_up_top <- ego_mf_up_top <- ego_bp_up_top <- data.frame("Description" = character(),
                                                                  "geneID" = character(),
                                                                  "enrichment" = character())
  }
  
  if(nrow(down) != 0){
    if(!identical(down$ORF, down$COMMON)) { # Filter out datasets where everything is unknown
      ego_bp_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "BP", pAdjustMethod = "bonferroni")
      ego_bp_down_top <- ego_bp_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "GO BP")
      
      ego_mf_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "MF", pAdjustMethod = "bonferroni")
      ego_mf_down_top <- ego_mf_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "GO MF")
      
      ego_cc_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "CC", pAdjustMethod = "bonferroni")
      if(class(ego_cc_down) == "NULL") {
        message("No enriched GO CC Down, moving on!")
        # make empty df so obj is rbind compliant
        ego_cc_down_top <- data.frame("Description" = character(), 
                                      geneID = character(), 
                                      enrichment = character())
      } else {
        ego_cc_down_top <- ego_cc_down@result %>%
          filter(p.adjust < 0.05) %>%
          dplyr::select(Description, geneID) %>%
          mutate(enrichment = "GO CC")
      } 
    } else {
      ego_cc_down_top <- ego_mf_down_top <- ego_bp_down_top <- data.frame("Description" = character(),
                                                                          "geneID" = character(),
                                                                          "enrichment" = character())
    }
  }  else {
    ego_cc_down_top <- ego_mf_down_top <- ego_bp_down_top <- data.frame("Description" = character(),
                                                                        "geneID" = character(),
                                                                        "enrichment" = character())
  }
  
  # COMBINE ENRICHMENT TABLES
  if(show_genes == T){
    down_tbl <- rbind(ego_bp_down_top, ego_cc_down_top, ego_mf_down_top, ekegg_down_top) 
    up_tbl <- rbind(ego_bp_up_top, ego_cc_up_top, ego_mf_up_top, ekegg_up_top)
  } else if(show_genes == F) {
    down_tbl <- rbind(ego_bp_down_top, ego_cc_down_top, ego_mf_down_top, ekegg_down_top) %>%
      dplyr::select(-geneID)
    up_tbl <- rbind(ego_bp_up_top, ego_cc_up_top, ego_mf_up_top, ekegg_up_top) %>%
      dplyr::select(-geneID)
  }


  # PRUNE PATHWAY NAMES TO FIRST X WORDS
  up_tbl$Description <- gsub(" \\(.*\\)", "", up_tbl$Description)
  up_tbl$Description <-gsub(" SSU.* from tricistronic rRNA transcript", " rRNA", up_tbl$Description)
  down_tbl$Description <- gsub(" \\(.*\\)", "", down_tbl$Description)
  down_tbl$Description <-gsub(" SSU.* from tricistronic rRNA transcript", " rRNA", down_tbl$Description)
  
  # PLOT ANNOTATION TABLES
  if(nrow(up_tbl) == 0){
    # make an empty table if there are no results
    up_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  } else {
    up_tbl <- ggtexttable(up_tbl,rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  }
  
  if(nrow(down_tbl) == 0){
    # make an empty table if there are no results
    down_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  } else {
    down_tbl <- ggtexttable(down_tbl,rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  }
  
  # PLOT DC
  # prep DF for plotting. Rename DC* to DC so that the same innvocation can be used
  # for ggplot across all plots
  dc <- dc %>%
    dplyr::select(DC = all_of(dc_num), brix, ava_id, ava, hr, sample)
  
  if(color_by == "brix"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = brix)) +
      geom_jitter() +
      scale_color_viridis_c() +      
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") 
  } else if(color_by == "ava") {
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = ava)) +
      geom_jitter() +
      theme_minimal() +
      labs(x = dc_num) +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") +
      scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                    "AS" = as, "SMV" = smv, "SRH" = srh)) 
  } else if(color_by == "hr"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = factor(hr, levels = c("0", "2", "6", "16", "64", "112")))) +
      geom_point() +
      scale_color_brewer(palette = "Paired", name = "hour") + 
      geom_jitter() +
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom")
    }

  # Plot chart and table into one object
  return(ggarrange(down_tbl, plt_dc, up_tbl, ncol = 3))
}

dc_top_diffex_plot <- function(dc, dc_num, dc_con, color_by = c("brix", "ava", "hr")){
  # dc <- dc19
  # dc_num <- "DC7"
  # dc_con <- dc7_19
  # color_by = "ava"
  # separate to induced and repressed -- note that filtering for 
  # log2fc is done in dc_contrast() when normalize_logFC = T. 
  # default is a normalizes logFC > abs(2) 
  # therefore, up down separates the positive and negative logFC values
  
  up_most <- dc_con %>%
    filter(logFC_adj > 0) %>%
    dplyr::select(COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>%
    dplyr::select(-logFC_adj) %>%
    head(n = 10)
  
  down_most <- dc_con %>%
    filter(logFC_adj < 0) %>%
    dplyr::select(COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>% 
    dplyr::select(-logFC_adj) %>%
    head(n = 10)
  
  # COMBINE ENRICHMENT TABLES
  # make an annotation table
  
  if(nrow(up_most) == 0){
    # make an empty table if there are no results
    up_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  } else{
    up_tbl <- ggtexttable(up_most, rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  }
  if(nrow(down_most) == 0){
    # make an empty table if there are no results
    down_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  } else {
    down_tbl <- ggtexttable(down_most,rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  }
  # PLOT DC
  # prep DF for plotting. Rename DC* to DC so that the same innvocation can be used
  # for ggplot across all plots
  dc <- dc %>%
    dplyr::select(DC = all_of(dc_num), brix, ava_id, ava, hr, sample)
  
  if(color_by == "brix"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = brix)) +
      geom_jitter() +
      scale_color_viridis_c() +
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") 
  } else if(color_by == "ava") {
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = ava)) +
      geom_jitter() +
      theme_minimal() +
      labs(x = dc_num) +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") +
      scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                    "AS" = as, "SMV" = smv, "SRH" = srh)) 
  } else if(color_by == "hr"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = factor(hr, levels = c("0", "2", "6", "16", "64", "112")))) +
      geom_point() +
      scale_color_brewer(palette = "Paired", name = "hour") + 
      geom_jitter() +
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom")
  } else {
      message("Please try a legitimate color values, either brix, ava, or hr")
    }

  # Plot chart and table into one object
  return(ggarrange(down_tbl, plt_dc, up_tbl, ncol = 3))
}

dc_top_table <- function(dc_con){
  up_most <- dc_con %>%
    filter(logFC > 0) %>%
    dplyr::select(ORF, COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>%
    dplyr::select(-logFC_adj) %>%
    head(n = 15)
  
  down_most <- dc_con %>%
    filter(logFC < 0) %>%
    dplyr::select(ORF, COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>%
    dplyr::select(-logFC_adj) %>%
    head(n = 15)
  
  most <- rbind(up_most, down_most)
  
  # add blank rows to enable printing when fewer than 30 diffex genes
  if(30-nrow(most) == 0){
    return(most)
  } else {
    blank_rows_to_add <- 30-nrow(most)
    blank_rows <- data.frame(ORF = rep("", blank_rows_to_add),
                             COMMON = rep("", blank_rows_to_add),
                             logFC = rep("", blank_rows_to_add))
    most <- rbind(most, blank_rows)
    return(most)
  }
}
```

```{r colors_avas}
#  ordered south to north
srh = "#FFAABB" # pink
smv = "#EE8866" # orange
as  = "#EEDD88" # light yellow
snc = "#99DDFF" # light cyan 
crn = "#AAAA00" # olive
rrv = "#BBCC33" # pear 
av  = "#77AADD" # light blue
or  = "#DDDDDD" # pale grey
```

# Introduction

<!-- This could be the introduction or it could be the first section of the results...it's going to depend on the target audience. -->

Gene expression is a dynamic process whereby a cell adjusts to its internal and external environment. 
While some biological processes occur in steady state, many are dynamic and require observation across time to understand the full complement of transcriptomic responses elicited by a stimuli.
In particular, environmental conditions that result in a global shift in gene expression (e.g. onset of hypoxia) require time series sampling to capture continuous metabolic remodelling.
Time series gene expression surveys have been successfully applied to these types of problems [@bendjilali2017time] (CITE brix paper). 
In these experiments, a single conditions was assayed to understand the ubiquitous global shifts in gene expression. 
Expanding such inquiries to multiple groups raises data analysis problems.

Time series profiles of cell populations rely on synchronicity between cells to identify coordinated shifts in gene expression.
Synchronicity is difficult to maintain across groups of cell populations exposed to different treatments.
Experimental techniques have been developed to resynchronize groups of cells, for example by arresting the cell cylce in the same phase across groups [@spellman1998comprehensive].
However these experimental approaches are not appropriate across broad experimental designs and may not be completely effective at re-synchronization [@lu2004statistical; @bar2012studying]. 

Identifying differences between groups that are separate from or in excess to the dominant and ubiquitous global shift in gene expression is another challenge.
Structure in gene expression exists at different scales [@moon2019visualizing], but dominant shifts experienced by all groups may overpower weaker but biologically important signals.
In experimental designs where groups undergo the same primary shift in metabolism but also react in subtly different ways, it's important to isolate and understand the transcriptomic context of those differences.
<!-- Further, while coordinated shifts in gene expression may occur across groups, sometimes there are additional differences between groups that can be difficult to identify when they are masked by global shifts.  -->

These computational problems have been addressed in part in by single cell RNA-sequencing analysis of differentiating cells.
As cells differentiate during development, absolute time may not reflect the extent of differentiation in an individual cell. 
Pseudotime analysis reorders asynchronous cells from absolute time to stage in differentiation relative to other cells undergoing the same process.
In particular, diffusion maps have been used to reorder asynchronously shifted cells because they preserve relationships between samples [@destiny2015].

Diffusion mapping is a manifold learning technique that uses information from the *k* most similar samples to construct non-linear composites of the major sources of variation among samples  [@coifman2005geometric; @coifman2006diffusion].
Dimensionality reduction algorithms like principal component analysis and t-distributed stochastic neighbor embedding (tSNE) are commonly applied to sequencing data to identify sources of variation [@way2020compressing; @moon2019visualizing].
Diffusion mapping has strengths over these methods because it is non-linear and robust to the "horseshoe effect" (unlike PCA) [@diaconis2008horseshoes], preserves distances between samples (unlike tSNE), and is insensitive to sampling density.

As a dimensionality reduction algorithm, diffusion maps extract latent variables that represent composite sources of variation between samples. 
Latent variables are unmeasured but are inferred from relationships in the sequencing data. 

Here, we use diffusion maps to analyze bulk time-series RNA-sequencing of global shifts of *Saccharomyces cerevisiae* metabolism during wine fermentation and hypoxia.
We use diffusion maps to resynchronize gene expression across treatment groups and to extract latent variables that represent the dominant sources of structure in the data sets.
Diffusion maps *per se* provides no suggestion of the underlying genes that lead to separation of samples along latent variables.
We apply differential expression along each diffusion component to determine the genes responsible for separation among samples.
We find that the primary diffussion component represents the dominant global shift in gene expression experienced by the majority of groups, while subsequent diffusion components represent subtler differences between groups. 

# Results

Diffusion maps extract latent variables that represent non-linear composites of genes that vary between samples. 
We refer to these latent variables as *diffusion components*.
Within each diffusion component, each sample is reprsented by a number and smpales that have similar gene expression profiles for genes summaried in that component are closer along the diffusion component.
Samples at the origin of a diffusion component do not vary along that component.
Differential expression along a diffusion component reveals the genes that contibute most to similarity among samples. 
Diffusion components capture diminishing structure among samples with the first accounting for the largest variation among all samples.


```{r metadata}
info <- read_csv("samples_ava.csv")
info$ava_id <- factor(info$ava_id, levels = c('OR1', 'OR2', 'AV1', 'AV2', 'RRV1', 
                                              'RRV2', 'RRV3', 'SNC1', 'SNC2', 
                                              'CRN1', 'AS1', 'AS2', 'SMV1', 
                                              'SMV2','SRH1'))

info$ava <- factor(info$ava, levels = c('OR', 'AV', 'RRV', 'SNC', 'CRN', 
                                        'AS', 'SMV','SRH'))
```

```{r diffusion_mapping_17, include = F}
## preprocess counts
counts17 <- read_tsv("v2017/outputs/counts/raw_counts.tsv") %>%
  filter(grepl(pattern = "^Y", x = gene)) %>%
  as.data.frame() %>%
  column_to_rownames("gene")
colnames(counts17) <- gsub("_readcounts.txt", "", colnames(counts17))
m17 <- sweep(counts17, 2, colSums(counts17), `/`)
m17 <- t(m17)

## build diffusion map
## as implemented here: https://doi.org/10.6084/m9.figshare.12864011.v4

nm <- m17 %>% norm.mat()          # normalize
aff <- nm %>%
  get_euc(., n.threads = 1) %>% 
  threshold(., top_k = 10)      # make affinity matrix
Lij <- aff %>% get_laplac()     # compute laplacian
eig <- eigen(Lij)               # smallest keig vectors
evl <- eig$values %>%           # get eigenvalues
  Re() %>%
  round(., digits = 10)
evc <- eig$vectors %>%          # get eigenvectors
  Re() %>%
  round(., digits = 10)

# create objects containing diffusion components
for(d in 1:length(evl)){
  assign(paste('dim', d, sep = '_'),
         Re(evc[, rank(evl) == (d + 1)])
  )
}

k_eig <- 10                     # specify num of variables you want to keep
dat <- do.call(mapply, c(FUN = cbind, mget(paste0("dim_", 1:(k_eig))))) %>%
  t() %>%
  as.data.frame()               # merge in array

colnames(dat) <- paste(paste('DC', 1:(k_eig), sep = ''))
rownames(dat) <- rownames(Lij)  # add labels

dc17 <- dat %>%                  # join with metadata
  rownames_to_column("sample") %>%
  left_join(info, by = c("sample" = "id"))
```

```{r plot_eig_vals17, eval = F}
tmp <- data.frame(val = eig$values) %>%
  arrange(val) %>%
  mutate(num = 1:length(eig$values))

ggplot(tmp, aes(y = val, x = num)) + 
  geom_point() +
  theme_minimal() +
  ggtitle("k=10 2017")
```

```{r diffusion_mapping_19, include = F}
counts19 <- read_tsv("v2019/outputs/counts/raw_counts.tsv") %>%
  dplyr::filter(grepl(pattern = "^Y", x = gene)) %>%
  dplyr::select(-`2019_inoculum_SRH1_readcounts.txt`,
                -`2019_inoculum_AS1_readcounts.txt`, 
                -`2019_inoculum_SMV2_readcounts.txt`,
                -`2019_inoculum_AS2_readcounts.txt`,
                -`2019_inoculum_RRV1_readcounts.txt`,
                -`2019_inoculum_SMV1_readcounts.txt`) %>%
  as.data.frame() %>%
  column_to_rownames("gene")
colnames(counts19) <- gsub("_readcounts.txt", "", colnames(counts19))

m19 <- sweep(counts19, 2, colSums(counts19), `/`)
m19 <- t(m19)                                             # transpose counts

## build diffusion map
## as implemented here: https://doi.org/10.6084/m9.figshare.12864011.v4

nm <- m19 %>% norm.mat()        # normalize
aff <- nm %>%
  get_euc(., n.threads = 1) %>% 
  threshold(., top_k = 10)      # make affinity matrix
Lij <- aff %>% get_laplac()     # compute laplacian
eig <- eigen(Lij)               # smallest keig vectors
evl <- eig$values %>%           # get eigenvalues
  Re() %>%
  round(., digits = 10)
evc <- eig$vectors %>%          # get eigenvectors
  Re() %>%
  round(., digits = 10)

# create objects containing diffusion components
for(d in 1:length(evl)){
  assign(paste('dim', d, sep = '_'),
         Re(evc[, rank(evl) == (d + 1)])
  )
}

k_eig <- 10                     # specify num of variables you want to keep
dat <- do.call(mapply, c(FUN = cbind, mget(paste0("dim_", 1:(k_eig))))) %>%
  t() %>%
  as.data.frame()               # merge in array

colnames(dat) <- paste(paste('DC', 1:(k_eig), sep = ''))
rownames(dat) <- rownames(Lij)  # add labels

dc19 <- dat %>%                 # join with metadata
  rownames_to_column("sample") %>%
  left_join(info, by = c("sample" = "id"))
```

```{r plot_eig_vals19, eval = F}
tmp <- data.frame(val = eig$values) %>%
  arrange(val) %>%
  mutate(num = 1:length(eig$values))

ggplot(tmp, aes(y = val, x = num)) + 
  geom_point() +
  theme_minimal() +
  ggtitle("k=10 2019")
```

```{r diffex17}
d0_17 <- DGEList(counts17)                         # initialize the DGE object
d17 <- calcNormFactors(d0_17)
dc_mm17 <- model.matrix(~dc17$DC1 + ~dc17$DC2 + ~dc17$DC3 + dc17$DC4 + dc17$DC5 + 
                          dc17$DC6 + dc17$DC7 + dc17$DC8 + dc17$DC9 + dc17$DC10)
dc_y17 <- voom(d17, dc_mm17, plot = F)
dc_fit17 <- lmFit(dc_y17, dc_mm17)
dc1_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 2) # Test "DC1" coefficient
dc2_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 3) # Test "DC2" coefficient
dc3_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 4) # Test "DC3" coefficient
dc4_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 5) # Test "DC4" coefficient
dc5_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 6) # Test "DC5" coefficient
dc6_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 7) # Test "DC6" coefficient
dc7_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 8) # Test "DC7" coefficient
dc8_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 9) # Test "DC8" coefficient
dc9_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 10) # Test "DC9" coefficient
dc10_17 <- dc_contrast(dc_fit = dc_fit17, coeff = 11) # Test "DC10" coefficient
```

```{r diffex19}
d0_19 <- DGEList(counts19)              # initialize the DGE object
d19 <-calcNormFactors(d0_19)            # calculate normalization factors
dc_mm19 <- model.matrix(~dc19$DC1 + ~dc19$DC2 + ~dc19$DC3 + dc19$DC4 + dc19$DC5 + 
                          dc19$DC6 + dc19$DC7 + ~dc19$DC8 + dc19$DC9 + dc19$DC10)
dc_y19 <- voom(d19, dc_mm19, plot = F)
dc_fit19 <- lmFit(dc_y19, dc_mm19)
dc1_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 2) # Test "DC1" coefficient
dc2_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 3) # Test "DC2" coefficient
dc3_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 4) # Test "DC3" coefficient
dc4_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 5) # Test "DC4" coefficient
dc5_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 6) # Test "DC5" coefficient
dc6_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 7) # Test "DC6" coefficient
dc7_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 8) # Test "DC7" coefficient
dc8_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 9) # Test "DC8" coefficient
dc9_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 10) # Test "DC9" coefficient
dc10_19 <- dc_contrast(dc_fit = dc_fit19, coeff = 11) # Test "DC10" coefficient
```

## Diffusion mapping captures the global shift of gene expression during primary fermentation

During wine fermentation, *S. cerevisiae* encounters overlapping stresses such as low pH and high sugar concentration in early fermentation give way to nutrient limitation and high ethanol concentration.
This dynamic environment leads to transcriptome remodelling throughout fermentation that allows *S. cerevisiae* to survive and dominant the transformation of grape must into wine [@rossignol2003genome; @marks2008dynamics] (CITE BRIX PAPER).
While *S. cerevsisiae* gene expression during fermentation is consistent across diverse fermentation conditions (CITE BRIX PAPER), the chemical composition of grape must and wine is variable.
Yet wines from the same vineyard site often have similar outcomes across multiple years (e.g. vintages) [@roullier2014grape; @cantu2020investigating].
This phenomenon is referred to as *terroir* -- the environmental and anthropomorphic factors contribute that to wine outcomes. 
We sought to uncover the quantifiable contribution of vineyard site to wine outcomes by using *S. cerevisiae* gene expression as a biosensor of differences between fermentations.
*S. cerevisiae* is one of the most well studied and annotated model organisms and so we took advantage of that information to uncover differences between fermentations from different vineyards.
We performed 60 inoculated primary fermentations of genetically similar Pinot noir grapes grown in 15 vineyards in California and Oregon over two vintages (**Figure \@ref(fig:fig1)**).
The initial grape must varied in paramters like initial nitrogen, pH, malic acid, tartaric acid, non-*Saccharomyces* microbial profile, and elemental profile while the final wines differed in volatile profiles and sensory outcomes (CITE sig of site paper).
Even still, *S. cerevisiae* had a consistent gene expression profile across fermentations from different vineyards and vintages (CITE brix paper).
Given the variable input media, we aimed to understand how fermentations differed, and whether those differences were related to genes known to impact the sensory outcome of wine [@cordente2012flavour].
We profiled each fermentation using time-course RNA sequencing and used *S. cerevisiae* gene expression as an indicator of similarities and difference across fermentation.
In the 2017 vintage, we took samples corresponding approximately to the early log phase (16 hours), late log phase (40 hours), stationary phase (64, 88 hours), and end of fermentation (112 hours). 
In the 2019 vintage, we shifted sampling forward to capture cellular adaptation after inoculation (2, 6 hours) and reduced sampling later in fermentation (16, 64, and 112 hours).
Fermentations progressed at different rates leading to asynchronous biological progression among samples with respect to absolute time (BRIX FIGURES).

```{r map, eval = FALSE, fig.cap = "A. Map of vineyard site American Viticulture Areas. B. Primary fermentation sampling time points for 2017 and 2019 vintages. Times are shown in hours and are relative to inoculation."}
map <- include_graphics("figures/map_and_sampling.pdf") 
```

```{r diffex_brix_17}
brix_counts17  <- counts17                    # non-wine samples already filtered
d0_17 <- DGEList(brix_counts17)               # initialize the DGE object
d17 <- calcNormFactors(d0_17)
brix_mm17 <- model.matrix(~dc17$brix)
brix_y17 <- voom(d17, brix_mm17, plot = F)
brix_fit17 <- lmFit(brix_y17, brix_mm17)
brix_17 <- dc_contrast(dc_fit = brix_fit17, coeff = 2) # Test brix coefficient
```

```{r diffex_brix_19, eval = T}
brix_counts19  <- counts19[ , 1:150]               # remove inoculum samples
d0_19 <- DGEList(brix_counts19)                    # initialize the DGE object
d19 <- calcNormFactors(d0_19)
brix19 <- info %>%
  dplyr::filter(year == 2019) %>%
  dplyr::filter(!is.na(brix))
brix_mm19 <- model.matrix(~brix19$brix)
brix_y19 <- voom(d19, brix_mm19, plot = F)
brix_fit19 <- lmFit(brix_y19, brix_mm19)
brix_19 <- dc_contrast(dc_fit = brix_fit19, coeff = 2) # Test brix coefficient
```

```{r brixcorr}
# make sure that everything has the same number of genes by not filtering by expression
# consider doing this from the outset (see above code) instead of just for this
# figure

brix_19_all <- dc_contrast(dc_fit = brix_fit19, coeff = 2, 
                           adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  mutate(logFC = logFC*-1)
brix_17_all <- dc_contrast(dc_fit = brix_fit17, coeff = 2,
                           adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  mutate(logFC = logFC*-1)
dc1_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 2, 
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF)
dc1_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 2,
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF)

# all.equal(brix_19_all$ORF, dc1_19_all$ORF, brix_17_all$ORF, dc1_17_all$ORF)

all_l2fc <- data.frame(brix19 = brix_19_all$logFC,
                       brix17 = brix_17_all$logFC,
                       DC1_17 = dc1_17_all$logFC,
                       DC1_19 = dc1_19_all$logFC) 
corr_l2fc <- cor(all_l2fc)
colnames(corr_l2fc) <- c("Brix 2019", "Brix 2017", "DC1 2017", "DC1 2019")
rownames(corr_l2fc) <- c("Brix 2019", "Brix 2017", "DC1 2017", "DC1 2019")


corr_plt <- ggcorrplot(corr_l2fc, type = "upper", show.diag = T, lab = T, 
                       hc.order = T, digits = 3, lab_size = 3, tl.cex = 9, 
                       lab_col = "white", show.legend = T,  legend.title =  "",
                       colors = brewer.pal(n = 3, name = "RdYlBu")) + 
  scale_fill_gradient2(low = brewer.pal(n = 3, name = "RdYlBu")[1], 
                       high = brewer.pal(n = 3, name = "RdYlBu")[3], 
                       mid = brewer.pal(n = 3, name = "RdYlBu")[2], 
                       midpoint = 0, limit = c(0, 1), space = "Lab", 
                       name = "") +
  theme(legend.position = "bottom")
```

```{r dc1, eval = FALSE, fig.height = 6, fig.width = 3.5, fig.cap = "Diffusion component 1 captures the metabolic transition that occurs as brix decreases during fermentation. The same transition occurs in **A.** the 2017 vintage and **B.** the 2019 vintage. Each point represents a sample from one time from one fermentation. Points that are closer along the x axis are more similar. The y axis is jittered to allow all points to be visualized. Points are colored by brix, where brix = 0 indicates end of fermentation. **C.** High concordance between differentially expressed genes in diffusion component 1 and genes that are differentially expressed as brix decreases."}
p17 <- ggplot(dc17, aes(x = DC1, y = 0, color = brix, label = ava_id)) +
  geom_jitter() +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  ggtitle("2017") 

p19 <- ggplot(dc19, aes(x = DC1, y = 0, color = brix, label = ava_id)) +
  geom_jitter() +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  ggtitle("2019") 

ggarrange(ggarrange(p17, p19, ncol = 1, nrow = 2, common.legend = T, legend = "bottom", labels = c(" ", " ")), corr_plt, labels = c("", " "), ncol = 1, nrow =2)
```

```{r fig1, fig.cap = "**A** Map of vineyard site American Viticulture Areas. **B** Primary fermentation sampling time points for 2017 and 2019 vintages. Times are shown in hours and are relative to inoculation. **C, D** Diffusion component 1 captures the metabolic transition that occurs as brix decreases during fermentation. The same transition occurs in the 2017 vintage and the 2019 vintage. Each point represents a sample from one time from one fermentation. Points that are closer along the x axis are more similar. The y axis is jittered to allow all points to be visualized. Points are colored by brix, where brix = 0 indicates end of fermentation. **E** High concordance between differentially expressed genes in diffusion component 1 and genes that are differentially expressed as brix decreases."}
include_graphics("figures/map_and_sampling2.pdf") 
```

When we apply diffusion mapping to wine fermentation, we find that diffusion component 1 captures the dominant metabolic transition of *S. cerevisiae* during fermentation and re-orders samples according to stage of fermentation (**Figure \@ref(fig:fig1)C-D**).
While we used different sampling schemes in the 2017 and 2019 vintages, samples are ordered by decreasing brix in both vintages.
Brix is a proxy for sugar concentration during fermentation, and sugar concentrations continuously drop as *S. cerevisiae* ferments sugar into ethanol.

In a previous investigation, we used brix to perform continuous differential expression and identified the ubiquitous transcriptome response of *S. cerevisiae* to Pinot noir fermentation (CITE BRIX PAPER).
To test whether diffusion mapping captures the genes known to change expression during fermentation, we performed differential expression over the diffusion component and compared the log~2~ fold change values of genes against those obtained with differential expression using brix.
Log~2~ fold change is strongly correlated between both methods of differential expression (**Figure \@ref(fig:fig1)E, Figure \@ref(fig:upsetgrid)**), indicating that the primary diffusion component captures the dominant global shift in gene expression during fermentation.

## Metabolic remodelling occurs throughout fermentation

We next explored subsequent diffusion components to determine the non-dominant drivers of structure among groups (**Figure \@ref(fig:allDCs2017)**, **Figure \@ref(fig:allDCs2019)**).
While progression through fermentation is the primary driver of separation among samples, consistent transitions in early fermentation and late fermentation drive secondary structure among samples.
Diffusion components capture cellular remodelling in early fermentation, entry into stationary phase, and starvation during late fermentation.

Incorporate **Table  \@ref(tab:numdiffex)**: In general, there are diminishing number of differentially expressed genes across diffusion components indicating increasingly subtle differences between samples.

```{r numdiffex}
num_diffex <- data.frame(diffusion_component = c("DC1", "DC2", "DC3", "DC4", 
                                                 "DC5", "DC6", "DC7", "DC8",
                                                 "DC9", "DC10"),
                         induced = c(length(filter(dc1_17, logFC > 0)$ORF),
                                     length(filter(dc2_17, logFC > 0)$ORF),
                                     length(filter(dc3_17, logFC > 0)$ORF),
                                     length(filter(dc4_17, logFC > 0)$ORF),
                                     length(filter(dc5_17, logFC > 0)$ORF),
                                     length(filter(dc6_17, logFC > 0)$ORF),
                                     length(filter(dc7_17, logFC > 0)$ORF),
                                     length(filter(dc8_17, logFC > 0)$ORF),
                                     length(filter(dc9_17, logFC > 0)$ORF),
                                     length(filter(dc10_17, logFC > 0)$ORF)),
                         repressed = c(length(filter(dc1_17, logFC < 0)$ORF),
                                       length(filter(dc2_17, logFC < 0)$ORF),
                                       length(filter(dc3_17, logFC < 0)$ORF),
                                       length(filter(dc4_17, logFC < 0)$ORF),
                                       length(filter(dc5_17, logFC < 0)$ORF),
                                       length(filter(dc6_17, logFC < 0)$ORF),
                                       length(filter(dc7_17, logFC < 0)$ORF),
                                       length(filter(dc8_17, logFC < 0)$ORF),
                                       length(filter(dc9_17, logFC < 0)$ORF),
                                       length(filter(dc10_17, logFC < 0)$ORF)),
                         induced = c(length(filter(dc1_19, logFC > 0)$ORF),
                                     length(filter(dc2_19, logFC > 0)$ORF),
                                     length(filter(dc3_19, logFC > 0)$ORF),
                                     length(filter(dc4_19, logFC > 0)$ORF),
                                     length(filter(dc5_19, logFC > 0)$ORF),
                                     length(filter(dc6_19, logFC > 0)$ORF),
                                     length(filter(dc7_19, logFC > 0)$ORF),
                                     length(filter(dc8_19, logFC > 0)$ORF),
                                     length(filter(dc9_19, logFC > 0)$ORF),
                                     length(filter(dc10_19, logFC > 0)$ORF)),
                         repressed = c(length(filter(dc1_19, logFC < 0)$ORF),
                                       length(filter(dc2_19, logFC < 0)$ORF),
                                       length(filter(dc3_19, logFC < 0)$ORF),
                                       length(filter(dc4_19, logFC < 0)$ORF),
                                       length(filter(dc5_19, logFC < 0)$ORF),
                                       length(filter(dc6_19, logFC < 0)$ORF),
                                       length(filter(dc7_19, logFC < 0)$ORF),
                                       length(filter(dc8_19, logFC < 0)$ORF),
                                       length(filter(dc9_19, logFC < 0)$ORF),
                                       length(filter(dc10_19, logFC < 0)$ORF))
)

kable(num_diffex, "latex", booktabs = T, col.names = c("diffusion component", "induced", "repressed", "induced", "repressed"),
      caption = 'Number of significantly differentially expressed genes for the top diffusion components for the 2017 and 2019 vintages') %>%
  kable_styling(font_size = 9) %>%
  add_header_above(c(" " = 1, "2017" = 2, "2019" = 2), align = "l", escape = F)
```


During the 2019 vintage, we sampled three times in early fermentation to capture the gene expression underlying the metabolic remodelling of *S. cerevisiae* during adaptation to the wine environment (high sugar, low pH).
Metabolic restructuring during early fermentation is bigger than transitions at end of fermentation.
Diffusion components 2 and 3 both differentiate early fermentation samples (2 hours, 6 hours, and 16 hours post-inoculation) while diffusion component 4, 6, and 8 differentiate late fermentation samples (64 hours, 112 hours post-inoculation). 

Notes about biology of transitions.

+ 2hr samples are more similar to 16 hours samples on diffusion component 2, which explains more of the variation among all samples.

Along DC2, genes *TIR1*, *TIR2*, *TIR3*, *DAN1*, and *TIR4* are the top 5 repressed genes, indicating gene expression for cell wall remodelling is highest at 16 hrs post inoculation.
Pathways like ribosome biogenesis, RNA transport, RNA degradation, and basal transcription factors are induced along DC2, while biosynthesis of amino acids, carbon metabolism, and steroid biosythesis are enriched in repressed genes (**Figure \@ref(fig:DC2viz2019)**), reflecting the stressful transition yeast make upon inoculation.


```{r v2019dc2dc3, fig.height = 5, fig.cap = "Metabolic transitions in early and late fermentation separate groups. **A, B** Diffusion components 2 and 3 capture variation in early fermentation. While late-fermentation samples cluster at the origin, early fermentation samples for three clusters. **C, D** Diffusion componenst 4 and 6 capture variation in late fermentation. While early fermentation samples cluster at the origin, late fermentation samples separate by time in fermentation and vineyard site region."}
by_hour <- ggplot(dc19, aes(x = DC2, y = DC3, color = factor(hr, levels = c("0", "2", "6", "16", "64", "112")), label = ava)) +
  geom_point(alpha = .6, size = 2) +
  scale_color_brewer(palette = "Paired", name = "hour") + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

by_ava <- ggplot(dc19, aes(x = DC2, y = DC3, color = ava, label = hr)) +
  geom_point(alpha = .6, size = 2) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 

by_hour_46 <- ggplot(dc19, aes(x = DC4, y = DC6, color = factor(hr, levels = c("0", "2", "6", "16", "64", "112")), label = ava)) +
  geom_point(alpha = .6, size = 2) +
  scale_color_brewer(palette = "Paired", name = "hour") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

by_ava_46 <- ggplot(dc19, aes(x = DC4, y = DC6, color = ava, label = ava)) +
  geom_point(alpha = .6, size = 2) +
  theme_minimal() +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme(plot.title = element_text(hjust = 0.5))


ggarrange(ggarrange(by_hour, by_hour_46, labels = c("A", "C"), legend = "bottom",
                    common.legend = T, nrow = 2),
          ggarrange(by_ava, by_ava_46, labels = c("B", "D"), legend = "bottom",
                    common.legend = T, nrow = 2), ncol = 2)

```

+ Early fermentation separation:
  + SMV sites/OR sites doing their own thing
+ End of fermentation separation
+ 2017 quality discussion: 

Unlike the 2019 vintage, we do not observe clear delineations among samples taken at the same time in late fermentation in the 2017 vintage.
While we detect dominant drives of variation among samples, e.g. gene expression remodelling during primary fermentation and transition from stationary phase to end of fermentation, we think that lack of grouping among samples may be indicative of a data quality issue.
All gene expression data are inherently noisey (CITE).
With advances in sequencing technology, we sequenced the 2019 vintage with unique molecular identifier (UMI) barcodes and thus were better able to demultiplex sequencing lanes and remove PCR duplicates. 
While diffusion mapping faithfully recapitulates the dominant metabolic processes in fermentation, we are skeptical that noise in the data interferes with our ability to draw further conclusions from higher diffusion components.

## Vineyard site differentiates samples within stages in fermentations

The extremes of each diffusion component represent samples with the most differentiated transcriptome for genes in that component.

+ DC2/DC3: SRH and OR are early outliers. We expect few differences given tight timeline of sampling, but cells from these fermentations may be at a different point in fermentation
+ DC4: 64-112 OR, SNC, and AS are in the middle instead of separating with the other 64/112 hour samples. More moderate fermentation behavior? (see below)
+ DC5: SEPARATION OF 2 HOURS SAMPLES - vitamins, cell wall, glycosyl. Look at microbiome of the sites on either side of the origin.
+ DC6: 64 hour OR samples. Less fatty acid metabolism but also 3 of the genes are nitrogen (PUT1, PUT2, DAL5). DC6 correlates with initial NOPA & NH3 -- 35%. Check nitrogen additions.
+ DC7: 16 hour samples, SMV vs. SRH. ADH4 SMV FUSEL ALCOHOL PRODUCTION. Very few differences bewteen these samples.
  + What could remediate this? look at redox balance etc. for what make ADH3 more active.
+ DC8: 112hr SNC and AS CELLULAR REPSONSE TO HYDROGEN PEROXIDE (check genes)
+ DC9: 6, 16hr samples; SMV. Phosphate (by eye), cell wall/extracellular region
+ DC10: 6, 2hr Cell wall remodelling; malic acid; heme binding; tetrapyrole binding

```{r eval = F}
tmp <- dc19 %>%
  column_to_rownames("sample") %>%
  dplyr::select(-wine_tube_id, -year, -ts_sum_id, -micro_id, -tank, -tank_letter, 
                -rootstock, -ava_id, -ava, -nutristart, -dap, -initial_yan,
                -total_gdd_f, -initial_brix)
ggcorrplot(cor(tmp), show.diag = T, lab = T,
           sig.level = 0.05, p.mat = cor_pmat(tmp), insig = "blank", 
           hc.order = T, digits = 2, lab_size = 2, tl.cex = 9, 
           lab_col = "white", show.legend = T,  legend.title =  "",
           colors = brewer.pal(n = 3, name = "RdYlBu")) + 
  theme(legend.position = "bottom")

####################
ggplot(dc19, aes(x = DC9, y = 0, color = factor(hr, levels = c("0", "2", "6", "16", "64", "112")), label = ava)) +
  geom_jitter(alpha = .6, size = 2) +
  scale_color_brewer(palette = "Paired", name = "hour") + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) 
```

## Diffusion mapping works on other data sets with global shifts in gene expression

OR

## Diffusion mapping reveals a coordinated response to hypoxia

While diffusion maps successfully distinguished major and minor differences in fermentations from vineyard sites, we were curious whether this method is broadly applicable to RNA-sequencing where global shifts in gene expression occurr.
To address this, we identified a time series gene expression profile of exposure of *S. cerevisiae* to hypoxia.
Hypoxia is...
The hypoxic response is organized by transcription factors...
Data set represents knock-out mutants of key transcription factors during a 240 minute gradual transition to hypoxia.

```{r hypoxia_functions}
dc_top_enrich_plot_hyp <- function(dc, dc_num, dc_con, color_by = c("time", "deletion"), show_genes = F){
  # dc <- dc19
  # dc_num <- "DC3"
  # dc_con <- dc3_19
  # separate to induced and repressed -- note that filtering for 
  # log2fc is done in dc_contrast() when normalize_logFC = T. 
  # default is a normalizes logFC > abs(2) 
  # therefore, up down separates the positive and negative logFC values
  
  up <- dc_con[dc_con$logFC > 0, ]
  down <- dc_con[dc_con$logFC < 0, ] 
               
  # KEGG enrichment
  if(nrow(up) != 0){
    ekegg_up <- enrichKEGG(up$ORF, "sce", pAdjustMethod = "bonferroni") 
    ekegg_up_top <- ekegg_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "KEGG") 
  } else {
    ekegg_up_top <- data.frame("Description" = character(),
                               "geneID" = character(),
                               "enrichment" = character())
  }
  
  if(nrow(down) != 0){
    if(!identical(down$ORF, down$COMMON)) { # Filter out datasets where everything is unknown
      ekegg_down <- enrichKEGG(down$ORF, "sce", pAdjustMethod = "bonferroni")
      ekegg_down_top <- ekegg_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "KEGG")
    } else {
      ekegg_down_top <- data.frame("Description" = character(),
                                   "geneID" = character(),
                                   "enrichment" = character())
    }
  } else {
    ekegg_down_top <- data.frame("Description" = character(),
                                 "geneID" = character(),
                                 "enrichment" = character())
  }
  
  # GO enrichment
  if(nrow(up) != 0){
    ego_bp_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "BP", pAdjustMethod = "bonferroni")
    ego_bp_up_top <- ego_bp_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO BP")
    
    ego_mf_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "MF", pAdjustMethod = "bonferroni")
    ego_mf_up_top <- ego_mf_up@result%>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO MF")
    
    ego_cc_up <- enrichGO(up$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                          ont = "CC", pAdjustMethod = "bonferroni")
    ego_cc_up_top <- ego_cc_up@result %>%
      filter(p.adjust < 0.05) %>%
      dplyr::select(Description, geneID) %>%
      mutate(enrichment = "GO CC")
  } else {
    ego_cc_up_top <- ego_mf_up_top <- ego_bp_up_top <- data.frame("Description" = character(),
                                                                  "geneID" = character(),
                                                                  "enrichment" = character())
  }
  
  if(nrow(down) != 0){
    if(!identical(down$ORF, down$COMMON)) { # Filter out datasets where everything is unknown
      ego_bp_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "BP", pAdjustMethod = "bonferroni")
      ego_bp_down_top <- ego_bp_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "GO BP")
      
      ego_mf_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "MF", pAdjustMethod = "bonferroni")
      ego_mf_down_top <- ego_mf_down@result %>%
        filter(p.adjust < 0.05) %>%
        dplyr::select(Description, geneID) %>%
        mutate(enrichment = "GO MF")
      
      ego_cc_down <- enrichGO(down$COMMON, OrgDb = org.Sc.sgd.db, keyType = "GENENAME", 
                              ont = "CC", pAdjustMethod = "bonferroni")
      if(class(ego_cc_down) == "NULL") {
        message("No enriched GO CC Down, moving on!")
        # make empty df so obj is rbind compliant
        ego_cc_down_top <- data.frame("Description" = character(), 
                                      geneID = character(), 
                                      enrichment = character())
      } else {
        ego_cc_down_top <- ego_cc_down@result %>%
          filter(p.adjust < 0.05) %>%
          dplyr::select(Description, geneID) %>%
          mutate(enrichment = "GO CC")
      } 
    } else {
      ego_cc_down_top <- ego_mf_down_top <- ego_bp_down_top <- data.frame("Description" = character(),
                                                                          "geneID" = character(),
                                                                          "enrichment" = character())
    }
  }  else {
    ego_cc_down_top <- ego_mf_down_top <- ego_bp_down_top <- data.frame("Description" = character(),
                                                                        "geneID" = character(),
                                                                        "enrichment" = character())
  }
  
  # COMBINE ENRICHMENT TABLES
  if(show_genes == T){
    down_tbl <- rbind(ego_bp_down_top, ego_cc_down_top, ego_mf_down_top, ekegg_down_top) 
    up_tbl <- rbind(ego_bp_up_top, ego_cc_up_top, ego_mf_up_top, ekegg_up_top)
  } else if(show_genes == F) {
    down_tbl <- rbind(ego_bp_down_top, ego_cc_down_top, ego_mf_down_top, ekegg_down_top) %>%
      dplyr::select(-geneID)
    up_tbl <- rbind(ego_bp_up_top, ego_cc_up_top, ego_mf_up_top, ekegg_up_top) %>%
      dplyr::select(-geneID)
  }


  # PRUNE PATHWAY NAMES TO FIRST X WORDS
  up_tbl$Description <- gsub(" \\(.*\\)", "", up_tbl$Description)
  up_tbl$Description <-gsub(" SSU.* from tricistronic rRNA transcript", " rRNA", up_tbl$Description)
  down_tbl$Description <- gsub(" \\(.*\\)", "", down_tbl$Description)
  down_tbl$Description <-gsub(" SSU.* from tricistronic rRNA transcript", " rRNA", down_tbl$Description)
  
  # PLOT ANNOTATION TABLES
  if(nrow(up_tbl) == 0){
    # make an empty table if there are no results
    up_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  } else {
    up_tbl <- ggtexttable(up_tbl,rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  }
  
  if(nrow(down_tbl) == 0){
    # make an empty table if there are no results
    down_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  } else {
    down_tbl <- ggtexttable(down_tbl,rows = NULL, theme = ttheme(base_size = 5, base_style = "blank", padding = unit(c(.5, .5), "mm")))
  }
  
  # PLOT DC
  # prep DF for plotting. Rename DC* to DC so that the same innvocation can be used
  # for ggplot across all plots
  dc <- dc %>%
    dplyr::select(DC = all_of(dc_num), sample, time, deletion)
  
  if(color_by == "time"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = time)) +
      geom_jitter() +
      scale_color_manual(values = brewer.pal(9, "Blues")[2:9]) +
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") 
  } else if(color_by == "deletion") {
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = deletion)) +
      geom_jitter() +
      theme_minimal() +
      labs(x = dc_num) +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom")
    }

  # Plot chart and table into one object
  return(ggarrange(down_tbl, plt_dc, up_tbl, ncol = 3))
}

dc_top_diffex_plot_hyp <- function(dc, dc_num, dc_con, color_by = c("time", "deletion")){
  # dc <- dc19
  # dc_num <- "DC7"
  # dc_con <- dc7_19
  # color_by = "ava"
  # separate to induced and repressed -- note that filtering for 
  # log2fc is done in dc_contrast() when normalize_logFC = T. 
  # default is a normalizes logFC > abs(2) 
  # therefore, up down separates the positive and negative logFC values
  
  up_most <- dc_con %>%
    filter(logFC_adj > 0) %>%
    dplyr::select(COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>%
    dplyr::select(-logFC_adj) %>%
    head(n = 10)
  
  down_most <- dc_con %>%
    filter(logFC_adj < 0) %>%
    dplyr::select(COMMON, logFC_adj) %>%
    mutate(logFC = round(logFC_adj, digits = 1)) %>% 
    dplyr::select(-logFC_adj) %>%
    head(n = 10)
  
  # COMBINE ENRICHMENT TABLES
  # make an annotation table
  
  if(nrow(up_most) == 0){
    # make an empty table if there are no results
    up_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  } else{
    up_tbl <- ggtexttable(up_most, rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  }
  if(nrow(down_most) == 0){
    # make an empty table if there are no results
    down_tbl <- ggtexttable(data.frame("No_sig_genes" = ""), rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  } else {
    down_tbl <- ggtexttable(down_most,rows = NULL, theme = ttheme(base_size = 6, base_style = "classic", padding = unit(c(1, 1), "mm")))
  }
  # PLOT DC
  # prep DF for plotting. Rename DC* to DC so that the same innvocation can be used
  # for ggplot across all plots
  dc <- dc %>%
    dplyr::select(DC = all_of(dc_num), time, deletion, sample)
  
  if(color_by == "time"){
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = time)) +
      geom_jitter() +
      scale_color_manual(values = brewer.pal(9, "Blues")[2:9]) +
      labs(x = dc_num) +
      theme_minimal() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") 
  } else if(color_by == "deletion") {
    plt_dc <- ggplot(dc, aes(x = DC, y = 0, color = deletion)) +
      geom_jitter() +
      theme_minimal() +
      labs(x = dc_num) +
      theme(plot.title = element_text(hjust = 0.5),
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "bottom") 
  } else {
      message("Please try a legitimate color values, either brix, ava, or hr")
    }

  # Plot chart and table into one object
  return(ggarrange(down_tbl, plt_dc, up_tbl, ncol = 3))
}
```

```{r preprocess_hypoxia}
hypoxia_info <- read_csv("hypoxia/hypoxia_info.csv")
files <- list.files("hypoxia/GSE115171_RAW", pattern = ".txt.gz$", recursive = T, full.names = T)
files <- c(files, list.files("hypoxia/GSE85595_RAW", pattern = "tab.gz", recursive = T, full.names = T))
counts <- files %>%
  purrr::set_names() %>% 
  map_dfr(function(x) read_tsv(x, col_names = c("gene", "count")), .id = "source") %>%
  mutate(source = gsub("\\.tabular\\.txt\\.gz", "", source)) %>%
  mutate(source = gsub("\\.tab.gz", "", source)) %>%
  mutate(source = gsub(".*\\/", "", source)) %>%
  filter(grepl(pattern = "^Y", x = gene)) %>%
  pivot_wider(id_cols = gene, names_from = source, values_from = count) %>%
  as.data.frame() %>%
  column_to_rownames("gene")

m <- counts
m <- sweep(m, 2, colSums(m), `/`)
m <- m[grepl("^Y", rownames(m)), ]                    # subset to mRNA
m <- t(m)                                             # transpose counts
```

```{r diffusion_mapping_hypoxia}
## Build diffusion map
nm <- m %>% norm.mat()        # normalize
aff <- nm %>%
  get_euc(., n.threads = 1) %>% 
  threshold(., top_k = 20)      # make affinity matrix
Lij <- aff %>% get_laplac()     # compute laplacian
eig <- eigen(Lij)               # smallest keig vectors
evl <- eig$values %>%           # get eigenvalues
  Re() %>%
  round(., digits = 10)
evc <- eig$vectors %>%          # get eigenvectors
  Re() %>%
  round(., digits = 10)

# create objects containing diffusion components
for(d in 1:length(evl)){
  assign(paste('dim', d, sep = '_'),
         Re(evc[, rank(evl) == (d + 1)])
  )
}

k_eig <- 20                     # specify num of variables you want to keep
dat <- do.call(mapply, c(FUN = cbind, mget(paste0("dim_", 1:(k_eig))))) %>%
  t() %>%
  as.data.frame()               # merge in array

colnames(dat) <- paste(paste('DC', 1:(k_eig), sep = ''))
rownames(dat) <- rownames(Lij)  # add labels

dc_hyp <- dat %>%               # join with metadata
  rownames_to_column("sample") %>%
  mutate(sample = gsub("GSM......._", "", sample)) %>%
  left_join(hypoxia_info, by = "sample")
```

```{r, eval = F}
tmp <- data.frame(val = eig$values) %>%
  arrange(val) %>%
  mutate(num = 1:length(eig$values))

ggplotly(ggplot(tmp, aes(y = val, x = num)) + 
  geom_point() +
  theme_minimal() +
  ggtitle("k=20 hypoxia"))
```

Diffusion component 1 captures the time-dependent transition to a hypoxic phenotype. 
Wild type cells experience a sharp transition from 0-5 minutes of nitrogen exposure, indicating a fast metabolic transition to hypoxia that matures over the remainder of the time course (**Figure \@ref(fig:DC1hypoxia)**).
Deletants deviate from this pattern and have slower transitions to a hypoxic phenotype or lack maintenance of that phenotype over the time course.

```{r DC1hypoxia, fig.height = 2, fig.cap="Diffusion map of wildtype and 22 mutant strains exposed to 100% nitrogen for 0-240 minutes. Wildtype cells are triangles, while mutants appear as points."}
dc_hyp$time <- as.factor(dc_hyp$time)
scat1 <- ggplot(data=subset(dc_hyp, deletion != "HAP1"), aes(x = DC1, y = 0, color = time, label = deletion)) +
  geom_jitter(size = 2) +
  scale_color_manual(values = brewer.pal(9, "Blues")[2:9]) +
  theme_minimal() +
  theme(plot.title.position = "plot") 

# add WT
scat1 + 
  geom_point(data=subset(dc_hyp, deletion == "HAP1"), aes(x = DC1, y = 0), shape = 17, size = 4, color = "black")+
  geom_point(data=subset(dc_hyp, deletion == "HAP1"), aes(x = DC1, y = 0), shape = 17, size = 3, fill = "black") 
```

```{r plot_hypoxia, eval=F}
plot_map_hypoxia <- function(dc_hyp, dc_num){
  dc_hyp$time <- as.factor(dc_hyp$time)
  dc_hyp <- dc_hyp %>%
    dplyr::select(DC = all_of(dc_num), time, deletion, sample)
  scat1 <- ggplot(data=subset(dc_hyp, deletion != "HAP1"), aes(x = DC, y = 0, color = time, label = deletion)) +
    geom_jitter(size = 2) +
    scale_color_manual(values = brewer.pal(9, "Blues")[2:9]) +
    theme_minimal() +
    theme(plot.title.position = "plot") +
    labs(x = dc_num)
  
  # add WT
  scat1 <- scat1 + 
    geom_point(data=subset(dc_hyp, deletion == "HAP1"), aes(x = DC, y = 0), shape = 17, size = 4, color = "black")+
    geom_point(data=subset(dc_hyp, deletion == "HAP1"), aes(x = DC, y = 0), shape = 17, size = 3, fill = "black") 
  return(scat1)
}

ggplotly(plot_map_hypoxia(dc_hyp, "DC1"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC2"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC3"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC4"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC5"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC6"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC7"))
ggplotly(plot_map_hypoxia(dc_hyp, 'DC8'))
ggplotly(plot_map_hypoxia(dc_hyp, "DC9"))
ggplotly(plot_map_hypoxia(dc_hyp, "DC10"))
#ggplotly(plot_map_hypoxia(dc_hyp, "DC12"))
#ggplotly(plot_map_hypoxia(dc_hyp, "DC14"))



```

```{r diffex_hypoxia}
d0 <- DGEList(counts)                          # initialize the DGE object
d <- calcNormFactors(d0)                       # calculate normalization factors
dc_hyp_mm <- model.matrix(~dc_hyp$DC1 + ~dc_hyp$DC2 + ~dc_hyp$DC3 + dc_hyp$DC4 + dc_hyp$DC5 + ~dc_hyp$DC6 + ~dc_hyp$DC7 + dc_hyp$DC8 + dc_hyp$DC9 + dc_hyp$DC10)
dc_hyp_y <- voom(d, dc_hyp_mm, plot = F)
dc_hyp_fit <- lmFit(dc_hyp_y, dc_hyp_mm)

dc1_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 2)
dc2_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 3)
dc3_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 4)
dc4_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 5)
dc5_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 6)
dc6_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 7)
dc7_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 8)
dc8_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 9)
dc9_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 10)
dc10_hyp <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 11)

dc1_hyp_all <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 2, adj.p.filt = 1, filter_logFC = F)
dc2_hyp_all <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 2, adj.p.filt = 1, filter_logFC = F)
```

```{r plot_top_hypoxia, eval = F, fig.height = 5, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 1. Only the top 10 enriched categories are displayed for each enrichment analysis. **A** KEGG pathways that are enriched in induced genes. **B** KEGG pathways that are enriched in repressed genes. **C** Gene Ontologies in category *biological processes* that are enriched in induced genes. **D** Gene Ontologies in category *biological processes* that are enriched in repressed genes."}

dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC1", dc_con = dc1_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC2", dc_con = dc2_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC3", dc_con = dc3_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC4", dc_con = dc4_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC5", dc_con = dc5_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC6", dc_con = dc6_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC7", dc_con = dc7_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC8", dc_con = dc8_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC9", dc_con = dc9_hyp, color_by = "time")
dc_top_diffex_plot_hyp(dc = dc_hyp, dc_num = "DC10", dc_con = dc10_hyp, color_by = "time")



dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC1", dc_con = dc1_hyp, color_by = "time")
dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC2", dc_con = dc2_hyp, color_by = "time")
dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC3", dc_con = dc3_hyp, color_by = "time")
dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC4", dc_con = dc4_hyp, color_by = "time")
dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC5", dc_con = dc5_hyp, color_by = "time")
dc_top_enrich_plot_hyp(dc = dc_hyp, dc_num = "DC6", dc_con = dc6_hyp, color_by = "time")
```

```{r dc_hyp1_filt}
# with log2fc > 2
dc1_hyp_up <- dc1_hyp %>%
  filter(logFC_adj > 0)
dc1_hyp_down <- dc1_hyp %>%
  filter(logFC_adj < 0)

# all sig
dc1_hyp_all_up <- dc1_hyp_all %>%
  filter(logFC_adj > 0) %>%
  filter(adj.P.Val < 0.05)
dc1_hyp_all_down <- dc1_hyp_all %>%
  filter(logFC_adj < 0) %>%
  filter(adj.P.Val < 0.05)
```

```{r dc_hyp2_filt}
dc2_hyp_up <- dc2_hyp %>%
  filter(logFC_adj > 0)
dc2_hyp_down <- dc2_hyp %>%
  filter(logFC_adj < 0)

dc2_hyp_all_up <- dc2_hyp_all %>%
  filter(logFC_adj > 0) %>%
  filter(adj.P.Val < 0.05)
dc2_hyp_all_down <- dc2_hyp_all %>%
  filter(logFC_adj < 0) %>%
  filter(adj.P.Val < 0.05)
```

We next investigated whether genes differentially expressed genes along diffusion component 1 match oxygen-regulated genes identified by seven previous microarray and RNA-sequencing studies of hypoxia [@bendjilali2017time].
Of the 11 genes that were characterized as oxygen-regulated in six or seven microarray studies, we identify eight in the first diffusion component with a log~2~ fold change greater than 2 while all 11 genes are significantly differentially expressed.

```{r oxygen_regulated_genes}
url <- "https://www.g3journal.org/highwire/filestream/473070/field_highwire_adjunct_files/15/TableS3.xlsx"
download.file(url = url, destfile = "hypoxia/inputs/tabs3_oxygen_regulated_genes.xlsx")
ox_reg <- readxl::read_excel(path = "hypoxia/inputs/tabs3_oxygen_regulated_genes.xlsx", 
                             col_names = c('ORF', 'COMMON', 'description', 'Becerra_2002',
                                           'Hickman_2007', 'Hickman_2011', 'Kwast_2002', 
                                           'Lai_2005', 'Lai_2006', 'terLinde_1999', 
                                           'terLinde_2002', 'hypoxic', 'aerobic', 'total'),
                             sheet = 1, skip = 1)

hypoxic1 <- ox_reg %>%
  group_by(hypoxic) %>%
  tally()

aerobic1 <- ox_reg %>%
  group_by(aerobic) %>%
  tally()
```

```{r test_hypoxia_intersect_microarray}
hypoxic_genes <- ox_reg %>%
  filter(hypoxic >= 6) %>%
  dplyr::select(ORF, COMMON)

hypoxic_genes_dc1_hyp <- hypoxic_genes[hypoxic_genes$ORF %in% dc1_hyp$ORF, ]

# try with log fc 1.5 instead of 2
dc1_hyp_p <- dc_contrast(dc_fit = dc_hyp_fit, coeff = 2, adj.p.filt = 1, filter_logFC = F) %>%
  filter(adj.P.Val < 0.05)
hypoxic_genes_dc1_hyp <- hypoxic_genes[hypoxic_genes$ORF %in% dc1_hyp_p$ORF, ]

```

```{r test_aerobic_intersect_microarray}
aerobic_genes <- ox_reg %>%
  filter(aerobic >= 6) %>%
  dplyr::select(ORF, COMMON)

aerobic_genes_dc1_hyp <- aerobic_genes[aerobic_genes$ORF %in% dc1_hyp$ORF, ]
aerobic_genes_dc2_hyp <- aerobic_genes[aerobic_genes$ORF %in% dc2_hyp$ORF, ]

# table(aerobic_genes_dc1_hyp$ORF %in% aerobic_genes_dc2_hyp$ORF)
# table(aerobic_genes$ORF %in% dc1_hyp$ORF)
# table(aerobic_genes$ORF %in% dc2_hyp$ORF)
```

[@bendjilali2017time] further characterized genes as hypoxic or aerobic using differential expression of wild type time series data set. 
To understand whether diffusion mapping captured the same oxygen-regulated genes, we intersected the hypoxic and aerobic genes with genes that were differentially expressed along DC1 and DC2 (**Table \@ref(tab:bendjilali)**). 
Two hundred thirty-nine of 291 (82.1%) genes predicted as aerobic by [@bendjilali2017time] were significantly induced prior to exposure to nitrogen, while 422 of 519 (81.3%) genes predicted as hypoxic significantly induced after prolonged exposure to nitrogen. 

```{r bendjilali}
url <- 'https://www.g3journal.org/highwire/filestream/473070/field_highwire_adjunct_files/13/TableS1.xlsx'
download.file(url = url, destfile = "hypoxia/inputs/tabs1_rnaseq_res.xlsx")
rnaseq_oxreg <- readxl::read_excel(path = "hypoxia/inputs/tabs1_rnaseq_res.xlsx", sheet = 1)%>%
  filter(grepl("^Y", gene))

hypoxic <- rnaseq_oxreg %>%
  filter(oxygen.regulated == "hypoxic") 

aerobic <- rnaseq_oxreg %>%
  filter(oxygen.regulated == "aerobic")

oxreg_int <- data.frame(intersection = c("DC1 induced", "DC1 repressed"),
                        hypoxic= c(table(hypoxic$gene %in% dc1_hyp_all_up$ORF)[2],
                                   table(hypoxic$gene %in% dc1_hyp_all_down$ORF)[2]),
                        aerobic = c(table(aerobic$gene %in% dc1_hyp_all_up$ORF)[2],
                                    table(aerobic$gene %in% dc1_hyp_all_down$ORF)[2]))
kable(oxreg_int, "latex", booktabs = T, col.names = c("Intersection", "Hypoxic (519 predicted)", "Aerobic (291 predicted)"),
      caption = 'Consistent hypoxic metabolic remodelling detected by Bendjilali et al. 2017 and this study. Genes induced along diffusion component 1 are involved in the hypoxic reponse while those that are repressed are involved in aerobic metabolism.') %>%
  kable_styling(font_size = 9)
```


# Discussion

In this study, we paired diffusion mapping with differential expression to capture primary fermentation of pinot noir wine measured with RNA-sequencing of musts from 15 vineyard sites. 
The time-ordered clustering of replicates and samples indicates that diffusion mapping captures time-varying patterns in this expression data set. 

Benefits of this method:

+ unbalanced sample designs (e.g. no replicates), because it uses linear regression over a continuous variable.
+ however, replication is still a good idea to make sure that a sample is not anomalous
+ uneven time series
+ compared to other methods, isolates time-varying responses in a component
+ easy to interpret a lot of samples given their relative distance to one another  


<!-- As model organism, the genes and pathways of *S. cerevisiae* are well annotated  -->
<!-- While diffusion mapping is  -->

# Methods

## Fermentation

## Sequencing and preprocessing

+ UC Davis DNA tech core
+ trimming, mapping, 2019 umi barcodes, htseq

We normalized read counts based on total number of reads per sample (library size) prior to constructing the diffusion map. 
As input to differential expression, we used raw sequencing counts and performed filtering and normalization with the limma package using the `calcNormFactors()` function [@limma2015].

## Construction of Diffusion Maps

Prior to diffusion map construction, we filtered gene counts to non-mitochondrial mRNA. 
We built the diffusion map using the Bioconductor package destiny [@destiny2015].
The destiny diffusion map algorithm accounts for noise types inherent in RNA-sequencing data such as missing values and uncertainties in measurements.

To select number of neighbors (k-size) in the construction of the diffusion map, we tested all values of *k* from 1 - (*n* - 2). 
We selected the k-size that produced a graph with one component and that maximized the difference between sequential eigenvalues when eigenvalues were ordered. 
We selected k-sizes of 31 for the 2017 vintage and 41 for the 2019 vintage.

## Differential expression

To determine which genes drove separation of samples along each component, we used differential expression to correlate each gene with diffusion component values.
We used limma to fit a linear regression model to each gene [@limma2015].
Using this model, the log~2~ fold change is the slope of the line for each unit increase in the diffusion component. 
We normalized log~2~ fold change values by calculating the length of the diffusion component (max - minimum) and multiplying all log~2~ fold change values by this amount. 
We analyzed log~2~ fold change values greater than two, i.e. genes with a log~2~ fold change of at least 2 between the most separated samples along a diffusion component.

+ clusterProfiler

## Comparison against differential expression with brix

# References

<div id="refs"></div>


\newpage
# Supplementary material {-}

\beginsupplement

```{r brix_upset17}
brix_list_17 <- list(dc1_17_induced = filter(dc1_17, logFC > 0)$ORF,
                     dc1_17_repressed = filter(dc1_17, logFC < 0)$ORF,
                     brix_17_induced = filter(brix_17, logFC > 0)$ORF,
                     brix_17_repressed = filter(brix_17, logFC < -0)$ORF
)
upset_brix_17 <- UpSetR::upset(fromList(brix_list_17), nsets = 8, nintersects = 200, 
                       order.by = "freq", keep.order = T)
```

```{r brix_upset19}
brix_list_19 <- list(dc1_19_induced = filter(dc1_19, logFC > 0)$ORF,
                     dc1_19_repressed = filter(dc1_19, logFC < 0)$ORF,
                     brix_19_induced = filter(brix_19, logFC > 0)$ORF,
                     brix_19_repressed = filter(brix_19, logFC < 0)$ORF
)
upset_brix_19 <- UpSetR::upset(fromList(brix_list_19), nsets = 8, nintersects = 200, 
                               order.by = "freq", keep.order = T)
```

```{r dc1_upset}
dc1_list <- list(dc1_17_induced = filter(dc1_17, logFC > 0)$ORF,
                 dc1_17_repressed = filter(dc1_17, logFC < 0)$ORF,
                 dc1_19_induced = filter(dc1_19, logFC > 0)$ORF,
                 dc1_19_repressed = filter(dc1_19, logFC < 0)$ORF)
upset_dc1 <- UpSetR::upset(fromList(dc1_list), nsets = 8, nintersects = 200, 
                   order.by = "freq", keep.order = T)
```

```{r brix_upset}
brix_list <- list(brix_17_induced = filter(brix_17, logFC > 0)$ORF,
                  brix_17_repressed = filter(brix_17, logFC < -0)$ORF,
                  brix_19_induced = filter(brix_19, logFC > 0)$ORF,
                  brix_19_repressed = filter(brix_19, logFC < 0)$ORF)
upset_brix <- UpSetR::upset(fromList(brix_list), nsets = 8, nintersects = 200, 
                   order.by = "freq", keep.order = T)
```

```{r upsetgrid, fig.height= 5, fig.cap="Upset plot depicting intersections between differentially expressed genes using diffusion component 1 or brix as continuous variable. **A.** Intersection of differentially expressed genes from the 2017 vintage. **B.** Intersection of genes from the 2019 vintage. **C.** Intersection of genes differentially expressed along diffusion component 1 from the 2017 and 2019 vintages. **D** Intersection of genes differentially expressed relative to change in brix from the 2017 and 2019 vintages."}

plot_grid(as.grob(upset_brix_17), as.grob(upset_brix_19), 
          as.grob(upset_dc1), as.grob(upset_brix),
          ncol = 2, labels = c("A", "B", "C", "D"))
```

```{r all_dc17_brix}
dc1_17p <- ggplot(dc17, aes(x = DC1, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc2_17p <- ggplot(dc17, aes(x = DC2, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc3_17p <- ggplot(dc17, aes(x = DC3, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc4_17p <- ggplot(dc17, aes(x = DC4, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc5_17p <-ggplot(dc17, aes(x = DC5, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc6_17p <-ggplot(dc17, aes(x = DC6, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc7_17p <-ggplot(dc17, aes(x = DC7, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc8_17p <-ggplot(dc17, aes(x = DC8, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc9_17p <-ggplot(dc17, aes(x = DC9, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc10_17p <-ggplot(dc17, aes(x = DC10, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

all_dc_17 <- ggarrange(dc1_17p, dc2_17p, dc3_17p, dc4_17p, dc5_17p, dc6_17p, 
                       dc7_17p, dc8_17p, dc9_17p, dc10_17p, legend = "bottom",
                       ncol = 1, common.legend = T, labels = c("B", "", "", "", "", "", "", "", "", ""))
```

```{r all_dc19_brix}
dc1_19p <- ggplot(dc19, aes(x = DC1, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc2_19p <- ggplot(dc19, aes(x = DC2, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc3_19p <- ggplot(dc19, aes(x = DC3, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc4_19p <- ggplot(dc19, aes(x = DC4, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_viridis_c() +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc5_19p <-ggplot(dc19, aes(x = DC5, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc6_19p <-ggplot(dc19, aes(x = DC6, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc7_19p <-ggplot(dc19, aes(x = DC7, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc8_19p <-ggplot(dc19, aes(x = DC8, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc9_19p <-ggplot(dc19, aes(x = DC9, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc10_19p <-ggplot(dc19, aes(x = DC10, y = 0, color = brix, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_viridis_c() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 
all_dc_19 <- ggarrange(dc1_19p, dc2_19p, dc3_19p, dc4_19p, dc5_19p, dc6_19p,
                       dc7_19p, dc8_19p, dc9_19p, dc10_19p, ncol = 1, legend = "bottom",
                       common.legend = T, labels = c("B", "", "", "", "", "", "", "", "", ""))
```

```{r all_dc17_ava}
dc1_17p <- ggplot(dc17, aes(x = DC1, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc2_17p <- ggplot(dc17, aes(x = DC2, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc3_17p <- ggplot(dc17, aes(x = DC3, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc4_17p <- ggplot(dc17, aes(x = DC4, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.3, .3)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc5_17p <-ggplot(dc17, aes(x = DC5, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc6_17p <-ggplot(dc17, aes(x = DC6, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc7_17p <-ggplot(dc17, aes(x = DC7, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc8_17p <-ggplot(dc17, aes(x = DC8, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc9_17p <-ggplot(dc17, aes(x = DC9, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc10_17p <-ggplot(dc17, aes(x = DC10, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.3, .3)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

all_dc_17_ava <- ggarrange(dc1_17p, dc2_17p, dc3_17p, dc4_17p, dc5_17p, dc6_17p, 
                           dc7_17p, dc8_17p, dc9_17p, dc10_17p, legend = "bottom",
                           ncol = 1, common.legend = T, labels = c("A", "", "", "", "", "", "", "", "", ""))
```

```{r all_dc19_ava}
dc1_19p <- ggplot(dc19, aes(x = DC1, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
          "AS" = as, "SMV" = smv, "SRH" = srh))

dc2_19p <- ggplot(dc19, aes(x = DC2, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc3_19p <- ggplot(dc19, aes(x = DC3, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc4_19p <- ggplot(dc19, aes(x = DC4, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  xlim(c(-0.51, .51)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc5_19p <-ggplot(dc19, aes(x = DC5, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc6_19p <-ggplot(dc19, aes(x = DC6, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank())

dc7_19p <-ggplot(dc19, aes(x = DC7, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc8_19p <-ggplot(dc19, aes(x = DC8, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc9_19p <-ggplot(dc19, aes(x = DC9, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 

dc10_19p <-ggplot(dc19, aes(x = DC10, y = 0, color = ava, label = ava_id)) +
  geom_jitter(alpha = .8) +
  xlim(c(-0.51, .51)) +
  scale_color_manual(values = c("OR"=or,  "AV" = av, "SNC" = snc, "RRV" = rrv, "CRN" = crn,
                                "AS" = as, "SMV" = smv, "SRH" = srh)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) 
all_dc_19_ava <- ggarrange(dc1_19p, dc2_19p, dc3_19p, dc4_19p, dc5_19p, dc6_19p,
                           dc7_19p, dc8_19p, dc9_19p, dc10_19p, ncol = 1, legend = "bottom",
                           common.legend = T, labels = c("A", "", "", "", "", "", "", "", "", ""))
```

```{r allDCs2017, fig.height= 9, fig.cap = "One-dimensional plots of diffusion components 1-10 for the 2017 vintage colored by **A** AVA and **B** brix. Diffusion components capture different latent structure in the dataset. Each component represents a different relationship among samples."}
ggarrange(all_dc_17_ava, all_dc_17, legend = "bottom")
```

```{r allDCs2019, fig.height= 9, fig.cap = "One-dimensional plots of diffusion components 1-10 for the 2019 vintage colored by **A** AVA and **B** brix. Diffusion components capture different latent structure in the dataset. Each component represents a different relationship among samples."}
ggarrange(all_dc_19_ava, all_dc_19, legend = "bottom")
```

```{r try_all_by_all_dc_corr, eval = F}

# brix, hr, initial_brix, initial_ph,
# initial_nopa, initial_nh3, initial_MA, lon, lat, total_gdd_c, total_ppt
dc1_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 2,
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc1_17_lfc = logFC_adj)
dc2_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 3,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc2_17_lfc = logFC_adj)
dc3_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 4,
                         adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc3_17_lfc = logFC_adj)
dc4_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 5,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc4_17_lfc = logFC_adj)
dc5_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 6,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc5_17_lfc = logFC_adj)
dc6_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 7,
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc6_17_lfc = logFC_adj)
dc7_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 8,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc7_17_lfc = logFC_adj)
dc8_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 9,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc8_17_lfc = logFC_adj)
dc9_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 10,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc9_17_lfc = logFC_adj)
dc10_17_all <- dc_contrast(dc_fit = dc_fit17, coeff = 11,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc10_17_lfc = logFC_adj)

## 2019
dc1_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 2,
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc1_19_lfc = logFC_adj)
dc2_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 3,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc2_19_lfc = logFC_adj)
dc3_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 4,
                         adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc3_19_lfc = logFC_adj)
dc4_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 5,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc4_19_lfc = logFC_adj)
dc5_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 6,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc5_19_lfc = logFC_adj)
dc6_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 7,
                          adj.p.filt = 1, filter_logFC = F) %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc6_19_lfc = logFC_adj)
dc7_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 8,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc7_19_lfc = logFC_adj)
dc8_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 9,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc8_19_lfc = logFC_adj)
dc9_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 10,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc9_19_lfc = logFC_adj)
dc10_19_all <- dc_contrast(dc_fit = dc_fit19, coeff = 11,
                          adj.p.filt = 1, filter_logFC = F)  %>%
  arrange(ORF) %>%
  select(ORF, COMMON, dc10_19_lfc = logFC_adj)

## COMBINE
dc_lfc_all <- list(dc1_17_all, dc2_17_all, dc3_17_all, dc4_17_all,
                   dc5_17_all, dc6_17_all, dc7_17_all, dc8_17_all,
                   dc9_17_all, dc10_17_all, dc1_19_all, dc2_19_all, 
                   dc3_19_all, dc4_19_all, dc5_19_all, dc6_19_all, 
                   dc7_19_all, dc8_19_all, dc9_19_all, dc10_19_all) %>% 
  purrr::reduce(left_join, by = c("ORF", "COMMON")) %>%
  select(-ORF) %>%
  column_to_rownames("COMMON")
corr_all <- cor(dc_lfc_all) 
is.na(corr_all) <- abs(corr_all) < 0.5
ggcorrplot(corr_all, type = "upper", show.diag = T, lab = T,
           digits = 2, lab_size = 3, tl.cex = 10, 
           lab_col = "white", show.legend = T,  legend.title =  "",
           colors = brewer.pal(n = 3, name = "RdYlBu")) + 
  theme(legend.position = "bottom") 



ggcorrplot(cor(dc_lfc_all), type = "upper", show.diag = F, lab = T,
           sig.level = 0.0000001, p.mat = cor_pmat(dc_lfc_all), insig = "blank", 
           hc.order = T, digits = 2, lab_size = 2, tl.cex = 9, 
           lab_col = "white", show.legend = T,  legend.title =  "",
           colors = brewer.pal(n = 3, name = "RdYlBu")) + 
  theme(legend.position = "bottom")
```

```{r annotatedplts17, fig.height = 4, fig.width = 6, eval = T, fig.cap="**A**, **B**"}
ggarrange(dc_top_diffex_plot(dc = dc17, dc_num = "DC1", dc_con = dc1_17, color_by = "brix"),
          dc_top_diffex_plot(dc = dc17, dc_num = "DC2", dc_con = dc2_17, color_by = "ava"),
          nrow = 2, labels = c("A", "B"))
```

```{r annotatedplts19, fig.height = 8, fig.width = 6, eval = T, fig.cap="**A**, **B**"}
ggarrange(dc_top_diffex_plot(dc = dc19, dc_num = "DC1", dc_con = dc1_19, color_by = "brix"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC2", dc_con = dc2_19, color_by = "hr"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC3", dc_con = dc3_19, color_by = "hr"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC4", dc_con = dc4_19, color_by = "hr"),
          nrow = 4, labels = c("A", "B", "C", "D"))
```

```{r annotatedplts192, fig.height = 8, fig.width=6, eval = T, fig.cap="**A**, **B**"}
ggarrange(dc_top_diffex_plot(dc = dc19, dc_num = "DC5", dc_con = dc5_19, color_by = "ava"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC6", dc_con = dc6_19, color_by = "ava"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC7", dc_con = dc7_19, color_by = "ava"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC8", dc_con = dc8_19, color_by = "ava"),
          nrow = 4, labels = c("A", "B", "C", "D"))
```

```{r annotatedplts193, fig.height = 4, fig.cap="**A**, **B**"}
ggarrange(dc_top_diffex_plot(dc = dc19, dc_num = "DC9", dc_con = dc9_19, color_by = "ava"),
          dc_top_diffex_plot(dc = dc19, dc_num = "DC10", dc_con = dc10_19, color_by = "ava"),
          nrow = 2, labels = c("A", "B"))
```

## Enrichment analysis 

```{r DC1viz2017, fig.height = 7.9, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 1 in the 2017 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc17, dc_num = "DC1", dc_con = dc1_17, color_by = "brix", show_genes = F)
```

```{r DC2viz2017, fig.height = 7.5, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 2 in the 2017 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc17, dc_num = "DC2", dc_con = dc2_17, color_by = "brix", show_genes = F)
```

```{r DC1viz2019, fig.height = 8, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 1 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC1", dc_con = dc1_19, color_by = "brix", show_genes = F)
```

```{r DC2viz2019, fig.height = 6.5, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 2 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC2", dc_con = dc2_19, color_by = "hr", show_genes = F)
```

```{r DC3viz2019, fig.height = 6, fig.cap= "Gene set enrichment for differentially expressed genes along diffusion component 3 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC3", dc_con = dc3_19, color_by = "hr", show_genes = F)
```

```{r DC4viz2019, fig.height = 3.2, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 4 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC4", dc_con = dc4_19, color_by = "hr", show_genes = F)
```

```{r DC5viz2019, fig.height = 2, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 5 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC5", dc_con = dc5_19, color_by = "hr", show_genes = F)
```

```{r DC6viz2019, fig.height = 2, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 6 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC6", dc_con = dc6_19, color_by = "ava", show_genes = F)
```

```{r DC7viz2019, fig.height = 3, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 7 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC7", dc_con = dc7_19, color_by = "ava", show_genes = F)
```

```{r DC8viz2019, fig.height = 1.7, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 8 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC8", dc_con = dc8_19, color_by = "ava", show_genes = F)
```

```{r DC9viz2019, fig.height = 2, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 9 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC9", dc_con = dc9_19, color_by = "ava", show_genes = F)
```

```{r DC10viz2019, fig.height = 2, fig.cap="Gene set enrichment for differentially expressed genes along diffusion component 10 in the 2019 vintage. All enriched categories with p < 0.05 after Bonferroni correction are shown. Pathways on the right side of the figure are induced in samples with a high diffusion component value, while pathways on the left of the figure are induced in samples with a low diffusion component value. Log~2~ fold change values reflect the total change in expression across the diffusion component."}
dc_top_enrich_plot(dc = dc19, dc_num = "DC10", dc_con = dc10_19, color_by = "ava", show_genes = F)
```

```{r test, eval = F, include = F, eval = F}
gene <- 'YPR065W' # ROX1
gene <- 'YMR070W' # MOT3
gene <- "YLR228C" # ECM22
gene <- 'YDR213W' # UPC2
gene <- 'YIR033W' # MGA2
gene <- 'YGL055W' # OLE1
gene <- 'YJR150C' # DAN1
gene <- 'YDR044W' # HEM13
Y <- dc_y$E[gene, ]
dc$Y = Y
ggplot(dc, aes(y = Y, x = DC2)) +
  geom_point(color = "grey", alpha = .7) +
  ggtitle(paste(gene, ", ", 
                dc2_top %>% filter(ORF == gene) %>% dplyr::select(COMMON),
                ": Log2FC = ", 
                dc2_top %>% filter(ORF == gene) %>% dplyr::select(logFC) %>% mutate(logFC = round(logFC, digits = 3))))+
  theme_minimal() +
  labs(y = "normalized log expression value") +
  #geom_text(x = -.05, y = 12.4, label=lm_eqn(dc, 'Y', 'DC2'), parse=T) +
  geom_smooth(method='lm')

```

```{r, eval = F}
tmp <- ggplot(dc17, aes(x = DC2, y = DC3, color = brix, label = ava_id)) +
  geom_jitter() +
  scale_color_viridis_c() +
  #scale_color_tableau(palette = "Tableau 20") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle("2017") 
ggplotly(tmp)
tmp <- ggplot(dc17, aes(x = DC2, y = DC3, color = ava, label = brix)) +
  geom_jitter() +
  #scale_color_viridis_c() +
  scale_color_tableau(palette = "Tableau 20") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle("2017")
tmp
ggplotly(tmp)
# DC1: brix
# DC2: late ferm; brix
# DC3: ?
# DC4: ?
# DC5: ?
# DC7: ?

p <- ggplot(dc19, aes(x = DC6, y = DC7, color = brix, label = ava_id)) +
  geom_jitter() +
  scale_color_viridis_c() +
  #scale_color_tableau(palette = "Tableau 20") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle("2019") 
ggplotly(p)
# DC1: brix
# DC2: early fermentation differences
# DC3: Wine from inoculum samples
# DC4: early ferm
# DC5: late ferm; brix
# DC6: early ferm
# DC7: early ferm

```

## hypoxia

```{r upsetplothypoxia, fig.cap="Upset plot showing intersections of genes that are significantly induced and repressed in DC1 and DC2 during hypoxia. The majority of genes are significantly differentially expressed in a single diffusion component."}
diffex_list <- list(DC1_induced = dc1_hyp_up$ORF,
                    DC1_repressed = dc1_hyp_down$ORF,
                    DC2_induced = dc2_hyp_up$ORF,
                    DC2_repressed = dc2_hyp_down$ORF)
upset(fromList(diffex_list))
```